unit AimFixHookunit;

interface

uses
  Windows, AddreUnit, Me2m4o1ryUnit;

Function AimFixSet : Boolean;
Procedure AimFix_Hack(Toggle: Boolean);

var
  Aim1lF80un0c: DWORD;
  AimFixAlloc, AimFixCopyAlloc, AimFixSwitchAlloc : DWORD;

Const
  AimFixBytes: Array[0..$24E] of Byte = ($8B, $FF, $F3, $0F, $10, $85, $3C, $FF,
    $FF, $FF, $8B, $FF, $8D, $8D, $D4, $FE, $FF, $FF, $8B, $FF, $F3, $0F, $11,
    $85, $00, $FF, $FF, $FF, $8B, $FF, $F3, $0F, $10, $85, $40, $FF, $FF, $FF,
    $8B, $FF, $F3, $0F, $11, $85, $04, $FF, $FF, $FF, $8B, $FF, $F3, $0F, $10,
    $85, $44, $FF, $FF, $FF, $8B, $FF, $F3, $0F, $11, $85, $08, $FF, $FF, $FF,
    $8B, $FF, $F3, $0F, $10, $45, $D8, $8B, $FF, $F3, $0F, $11, $85, $0C, $FF,
    $FF, $FF, $8B, $FF, $F3, $0F, $10, $45, $DC, $8B, $FF, $F3, $0F, $11, $85,
    $10, $FF, $FF, $FF, $8B, $FF, $F3, $0F, $10, $45, $E0, $8B, $FF, $F3, $0F,
    $11, $85, $14, $FF, $FF, $FF, $8B, $FF, $F3, $0F, $10, $85, $74, $FF, $FF,
    $FF, $8B, $FF, $89, $85, $18, $FF, $FF, $FF, $8B, $FF, $F3, $0F, $11, $85,
    $20, $FF, $FF, $FF, $8B, $FF, $F3, $0F, $11, $85, $1C, $FF, $FF, $FF, $8B,
    $FF, $C7, $85, $34, $FF, $FF, $FF, $00, $00, $00, $00, $8B, $FF, $C6, $87,
    $E4, $03, $00, $00, $00, $8B, $FF, $E8, $27, $96, $FE, $CB, $8B, $FF, $D8,
    $25, $58, $41, $55, $1A, $8B, $FF, $8B, $0D, $3C, $86, $82, $1A, $8B, $FF,
    $D8, $8D, $20, $FF, $FF, $FF, $8B, $FF, $D9, $9D, $20, $FF, $FF, $FF, $8B,
    $FF, $E8, $80, $63, $20, $CC, $8B, $FF, $8B, $4F, $38, $8B, $FF, $89, $85,
    $38, $FF, $FF, $FF, $8B, $FF, $8B, $81, $CC, $05, $00, $00, $8B, $FF, $89,
    $45, $80, $8B, $FF, $E8, $3F, $EF, $63, $CC, $8B, $FF, $85, $C0, $8B, $FF,
    $74, $1E, $8B, $07, $8B, $CF, $8B, $80, $5C, $01, $00, $00, $FF, $D0, $85,
    $C0, $74, $0E, $8B, $47, $38, $8B, $80, $1C, $42, $00, $00, $89, $45, $80,
    $EB, $03, $8B, $45, $80, $8B, $0D, $5C, $D0, $81, $1A, $8B, $FF, $83, $B9,
    $AC, $D7, $00, $00, $13, $8B, $FF, $75, $16, $50, $E8, $0D, $D7, $98, $CC,
    $8B, $C8, $E8, $D6, $F9, $98, $CC, $8B, $0D, $5C, $D0, $81, $1A, $89, $45,
    $80, $83, $B9, $AC, $D7, $00, $00, $41, $8B, $FF, $75, $16, $8D, $85, $58,
    $FF, $FF, $FF, $50, $8D, $85, $F4, $FE, $FF, $FF, $50, $E8, $BF, $B5, $81,
    $CC, $83, $C4, $08, $E8, $D7, $F4, $87, $CC, $8B, $FF, $83, $F8, $44, $8B,
    $FF, $75, $20, $8B, $0D, $78, $D3, $81, $1A, $8D, $85, $58, $FF, $FF, $FF,
    $50, $8D, $85, $F4, $FE, $FF, $FF, $50, $E8, $E5, $19, $63, $CC, $8B, $C8,
    $E8, $1E, $56, $86, $CC, $83, $7D, $80, $00, $8B, $FF, $C7, $85, $7C, $FF,
    $FF, $FF, $00, $00, $00, $00, $8B, $FF, $0F, $8E, $75, $CF, $6A, $CC, $8B,
    $FF, $0F, $1F, $40, $00, $8B, $FF, $0F, $1F, $84, $00, $00, $00, $00, $00,
    $8B, $FF, $FF, $B7, $54, $02, $00, $00, $8B, $FF, $F3, $0F, $10, $85, $64,
    $FF, $FF, $FF, $8B, $FF, $8D, $85, $F4, $FE, $FF, $FF, $8B, $FF, $FF, $B5,
    $38, $FF, $FF, $FF, $8B, $FF, $8B, $0D, $98, $D3, $81, $1A, $8B, $FF, $FF,
    $77, $38, $8B, $FF, $F3, $0F, $11, $85, $F4, $FE, $FF, $FF, $8B, $FF, $F3,
    $0F, $10, $85, $68, $FF, $FF, $FF, $8B, $FF, $F3, $0F, $11, $85, $F8, $FE,
    $FF, $FF, $8B, $FF, $F3, $0F, $10, $85, $6C, $FF, $FF, $FF, $8B, $FF, $50,
    $8B, $FF, $F3, $0F, $11, $85, $FC, $FE, $FF, $FF, $8B, $FF, $E8, $CB, $67,
    $64, $CC, $8B, $FF, $8D, $85, $34, $FF, $FF, $FF, $8B, $FF, $8B, $CF, $8B,
    $FF, $50, $8B, $FF, $8D, $85, $3C, $FF, $FF, $FF, $8B, $FF, $50);

implementation

uses Main1F0mer;

Function AimFixSet : Boolean;
Const
  AimFixBaseAsm: Array[0..86] of Byte = ($81, $3C, $24, $15, $14, $B0, $50, $0F,
    $85, $0B, $00, $00, $00, $90, $90, $90, $90, $C7, $04, $24, $00, $00, $1A,
    $10, $83, $3D, $00, $00, $37, $03, $00, $0F, $84, $2D, $00, $00, $00, $90,
    $90, $90, $90, $8B, $41, $38, $85, $C0, $0F, $84, $1B, $00, $00, $00, $8B,
    $40, $20, $50, $8B, $44, $24, $04, $83, $C0, $0C, $81, $38, $8B, $D0, $89,
    $55, $58, $0F, $85, $02, $00, $00, $00, $31, $C0, $C3, $31, $C0, $C3, $E9,
    $99, $21, $98, $40);
begin
  Aim1lF80un0c := RPM4Byte(C0py4d42 + $90);

  AimFixAlloc := DWORD(VirtualAllocEx(hProcess, Nil, $1, MEM_COMMIT, PAGE_EXECUTE_READWRITE));
  AimFixCopyAlloc := DWORD(VirtualAllocEx(hProcess, Nil, $1, MEM_COMMIT, PAGE_EXECUTE_READWRITE));
  AimFixSwitchAlloc := DWORD(VirtualAllocEx(hProcess, Nil, $1, MEM_COMMIT, PAGE_EXECUTE_READWRITE));

  WriteProcessMemory(hProcess, ptr(AimFixAlloc), @AimFixBaseAsm, SizeOf(AimFixBaseAsm), PNativeUint(Nil)^);

  Wpm4Byte(AimFixAlloc + 3, cshell.Addr + AimFixAddr);
  Wpm4Byte(AimFixAlloc + $14, AimFixCopyAlloc);
  Wpm4Byte(AimFixAlloc + $1A, AimFixSwitchAlloc);
  JmpHook(AimFixAlloc + $52, Aim1lF80un0c, 0);

  WriteProcessMemory(hProcess, ptr(AimFixCopyAlloc), @AimFixBytes, SizeOf(AimFixBytes), PNativeUint(Nil)^);

  CallHook(AimFixCopyAlloc + $B4, FindDestinationOfHook(cshell.Addr + AimFixAddr + $8C), 0);
  CallHook(AimFixCopyAlloc + $DB, FindDestinationOfHook(cshell.Addr + AimFixAddr + $A9), 0);
  CallHook(AimFixCopyAlloc + $FC, FindDestinationOfHook(cshell.Addr + AimFixAddr + $C0), 0);
  CallHook(AimFixCopyAlloc + $13E, FindDestinationOfHook(cshell.Addr + AimFixAddr + $FA), 0);
  CallHook(AimFixCopyAlloc + $145, FindDestinationOfHook(cshell.Addr + AimFixAddr + $101), 0);
  CallHook(AimFixCopyAlloc + $16C, FindDestinationOfHook(cshell.Addr + AimFixAddr + $126), 0);
  CallHook(AimFixCopyAlloc + $174, FindDestinationOfHook(cshell.Addr + AimFixAddr + $12E), 0);
  CallHook(AimFixCopyAlloc + $196, FindDestinationOfHook(cshell.Addr + AimFixAddr + $14C), 0);
  CallHook(AimFixCopyAlloc + $19D, FindDestinationOfHook(cshell.Addr + AimFixAddr + $153), 0);
  JngHook(AimFixCopyAlloc + $1B5, FindDestinationOfHook(cshell.Addr + AimFixAddr + $167), 0);
  CallHook(AimFixCopyAlloc + $230, FindDestinationOfHook(cshell.Addr + AimFixAddr + $1C4), 0);

  Wpm4Byte(AimFixCopyAlloc + $BB + $2, Rpm4Byte(cshell.Addr + AimFixAddr + $91 + $2));
  Wpm4Byte(AimFixCopyAlloc + $C3 + $2, Rpm4Byte(cshell.Addr + AimFixAddr + $97 + $2));
  Wpm4Byte(AimFixCopyAlloc + $12A + $2, Rpm4Byte(cshell.Addr + AimFixAddr + $EA + $2));
  Wpm4Byte(AimFixCopyAlloc + $14A + $2, Rpm4Byte(cshell.Addr + AimFixAddr + $106 + $2));
  Wpm4Byte(AimFixCopyAlloc + $182 + $2, Rpm4Byte(cshell.Addr + AimFixAddr + $138 + $2));
  Wpm4Byte(AimFixCopyAlloc + $1EE + $2, Rpm4Byte(cshell.Addr + AimFixAddr + $192 + $2));

  JmpHook(AimFixCopyAlloc + $24F, cshell.Addr + AimFixAddr + $1D9, 0);

  Wpm4Byte(ModuleCopyAdr + C0py4d43 + $90, AimFixAlloc);
end;

Procedure AimFix_Hack(Toggle: Boolean);
const
  AimFixAsm: Array [0 .. 4] of Byte = ($83, $C4, $10, $90, $90);
begin
  if Toggle then
    WriteProcessMemory(hProcess, Pointer(AimFixCopyAlloc + $230), @AimFixAsm, SizeOf(AimFixAsm), PNativeUint(nil)^)
  else
    CallHook(AimFixCopyAlloc + $230, FindDestinationOfHook(cshell.addr + AimFixAddr + $1C4), 0);
end;

end.

unit Auto1Bot3Unit;

interface

Uses
  WinApi.Windows, AddreUnit, Me2m4o1ryUnit, SysUtils, Math;

Procedure B5o1S8e1t;
Procedure P2la4ye8rk1;
Procedure Aut882o1;
Procedure HookPlayer;

Function XYHo8o1kS6et: Boolean;

Function GetPla8ye1rMa9trix(hO8b51j: DWORD; Bo8neNa5m1e: String): DWORD;
Function GetPla0yerM0atr2ix2(h8O8b0j: DWORD; O1f58f: Integer): DWORD;

type
  TPosition = record
    X, Z, Y: Single;
    L, T, U, I: Byte;
    A: String;
  end;

Var
  A3dX, Ai34Y: DWORD;
  PldOr3di435gil: DWORD;
  Idn3dfex, No15Num, N3o4d5e5N4ames, P4a5ram, Bu3f4f5er: DWORD;
  POr8i16nalPtr: Array [0 .. 1] of DWORD;
  PHo4ok854Alloc: Array [0 .. 31] of DWORD;
  P5P4t8r0: Array [0 .. 31] of DWORD;
  V0i0s3idStatus: Array [0 .. 31] of DWORD;
  N9o5d12es: Array [0 .. 31] of DWORD;

implementation

uses
  Main1F0mer, Gui14d4edUnit;

Procedure Bo8neNa5m1e;
begin
  WPMString(N3o4d5e5N4ames, 'Bip01 Head');
  WPMString(N3o4d5e5N4ames + $20 * 1, 'Bip01 L Clavicle');
  WPMString(N3o4d5e5N4ames + $20 * 2, 'Bip01 L UpperArm');
  WPMString(N3o4d5e5N4ames + $20 * 3, 'Bip01 L Forearm');
  WPMString(N3o4d5e5N4ames + $20 * 4, 'Bip01 L Hand');
  WPMString(N3o4d5e5N4ames + $20 * 5, 'Bip01 R Clavicle');
  WPMString(N3o4d5e5N4ames + $20 * 6, 'Bip01 R UpperArm');
  WPMString(N3o4d5e5N4ames + $20 * 7, 'Bip01 R Forearm');
  WPMString(N3o4d5e5N4ames + $20 * 8, 'Bip01 R Hand');
  WPMString(N3o4d5e5N4ames + $20 * 9, 'Bip01 Neck');
  WPMString(N3o4d5e5N4ames + $20 * 10, 'Bip01 Spine2');
  WPMString(N3o4d5e5N4ames + $20 * 11, 'Bip01 Spine1');
  WPMString(N3o4d5e5N4ames + $20 * 12, 'Bip01 Spine');
  WPMString(N3o4d5e5N4ames + $20 * 13, 'Bip01 Pelvis');
  WPMString(N3o4d5e5N4ames + $20 * 14, 'Bip01 R Thigh');
  WPMString(N3o4d5e5N4ames + $20 * 15, 'Bip01 R Calf');
  WPMString(N3o4d5e5N4ames + $20 * 16, 'Bip01 R Foot');
  WPMString(N3o4d5e5N4ames + $20 * 17, 'Bip01 R Toe0');
  WPMString(N3o4d5e5N4ames + $20 * 18, 'Bip01 L Thigh');
  WPMString(N3o4d5e5N4ames + $20 * 19, 'Bip01 L Calf');
  WPMString(N3o4d5e5N4ames + $20 * 20, 'Bip01 L Foot');
  WPMString(N3o4d5e5N4ames + $20 * 21, 'Bip01 L Toe0');
end;

Procedure B5o1S8e1t;
const
  H1050k4m: Array [0 .. 346] of Byte = ($60, $A1, $EC, $45, $AE, $5A, $85, $C0,
    $0F, $84, $02, $01, $00, $00, $8B, $40, $10, $85, $C0, $0F, $84, $F7, $00,
    $00, $00, $8B, $80, $B0, $02, $00, $00, $85, $C0, $0F, $84, $E9, $00, $00,
    $00, $8B, $C8, $8B, $00, $85, $C0, $0F, $84, $DD, $00, $00, $00, $8B, $40,
    $08, $85, $C0, $0F, $84, $D2, $00, $00, $00, $FF, $D0, $85, $C0, $0F, $84,
    $C8, $00, $00, $00, $8B, $F0, $C7, $05, $00, $00, $B1, $33, $00, $00, $00,
    $00, $83, $3D, $00, $00, $B1, $33, $16, $0F, $83, $AF, $00, $00, $00, $8B,
    $1D, $00, $00, $B1, $33, $6B, $DB, $20, $81, $C3, $00, $00, $60, $03, $68,
    $00, $00, $F2, $00, $53, $56, $E8, $04, $8B, $39, $FD, $84, $C0, $0F, $85,
    $92, $00, $00, $00, $6A, $01, $68, $00, $04, $F2, $00, $FF, $35, $00, $00,
    $F2, $00, $56, $E8, $99, $8C, $39, $FD, $84, $C0, $0F, $85, $77, $00, $00,
    $00, $8D, $05, $00, $04, $F2, $00, $8B, $1D, $00, $00, $B1, $33, $6B, $DB,
    $40, $81, $C3, $00, $00, $EF, $00, $8B, $08, $89, $0B, $8B, $48, $04, $89,
    $4B, $04, $8B, $48, $08, $89, $4B, $08, $8D, $05, $78, $13, $74, $00, $8B,
    $18, $89, $1D, $0C, $04, $F2, $00, $8B, $58, $04, $89, $1D, $10, $04, $F2,
    $00, $8B, $58, $08, $89, $1D, $14, $04, $F2, $00, $6A, $00, $68, $00, $00,
    $B0, $33, $68, $00, $04, $F2, $00, $E8, $6B, $B7, $29, $FD, $83, $C4, $0C,
    $8B, $1D, $00, $00, $B1, $33, $6B, $DB, $04, $81, $C3, $00, $00, $F1, $00,
    $34, $01, $88, $03, $E9, $40, $00, $00, $00, $61, $E9, $6A, $49, $65, $3C,
    $8B, $1D, $00, $00, $B1, $33, $6B, $DB, $40, $81, $C3, $00, $00, $EF, $00,
    $C7, $03, $00, $00, $00, $00, $C7, $43, $04, $00, $00, $00, $00, $C7, $43,
    $08, $00, $00, $00, $00, $8B, $1D, $00, $00, $B1, $33, $6B, $DB, $04, $81,
    $C3, $00, $00, $F1, $00, $C6, $03, $00, $E9, $00, $00, $00, $00, $FF, $05,
    $00, $00, $B1, $33, $E9, $F9, $FE, $FF, $FF);
var
  Index: Integer;
  Rd518uf: Array [0 .. $300] of Byte;
begin
{$I .\Include\Virtualizer_Start.inc}
  PldOr3di435gil :=
    RPM4Byte(RPM4Byte(RPM4Byte(PlayerPointerDecrypt
    (RPM4Byte(RPM4Byte(RPM4Byte(cshell.Addr + PlayerAd)) + $2B0)) +
    $ACC)) + $2C);
  POr8i16nalPtr[0] :=
    RPM4Byte(RPM4Byte(PlayerPointerDecrypt
    (RPM4Byte(RPM4Byte(RPM4Byte(cshell.Addr + PlayerAd)) + $2B0)) + $ACC));
  POr8i16nalPtr[1] :=
    RPM4Byte(RPM4Byte(RPM4Byte(PlayerPointerDecrypt
    (RPM4Byte(RPM4Byte(RPM4Byte(cshell.Addr + PlayerAd)) + $2B0)) + $ACC)));
  Idn3dfex := VAE($1);
  No15Num := VAE($1);
  N3o4d5e5N4ames := VAE($1);
  P4a5ram := VAE($1);
  Bu3f4f5er := VAE($1);
{$I .\Include\Virtualizer_End.inc}
  Bo8neNa5m1e;
  for Index := 0 to 31 do
  begin
{$I .\Include\Virtualizer_Start.inc}
    PHo4ok854Alloc[Index] := VAE($1);
    V0i0s3idStatus[Index] := VAE($1);
    N9o5d12es[Index] := VAE($1);
{$I .\Include\Virtualizer_End.inc}
    WriteProcessMemory(hProcess, Pointer(PHo4ok854Alloc[Index]), @H1050k4m,
      Sizeof(H1050k4m), Pnativeuint(nil)^);
{$I .\Include\Virtualizer_Start.inc}
    WPM4Byte(PHo4ok854Alloc[Index] + 2, cshell.Addr + PlayerAd);

    if Index = 0 then
      WPM4Byte(PHo4ok854Alloc[Index] + $E, $8590008B)
    else
      WPM1Byte(PHo4ok854Alloc[Index] + $10, Index * 4);

    WPM4Byte(PHo4ok854Alloc[Index] + $4C, Idn3dfex);
    WPM4Byte(PHo4ok854Alloc[Index] + $56, Idn3dfex);
    WPM4Byte(PHo4ok854Alloc[Index] + $63, Idn3dfex);
    WPM4Byte(PHo4ok854Alloc[Index] + $6C, N3o4d5e5N4ames);
    WPM4Byte(PHo4ok854Alloc[Index] + $71, No15Num);
    CallHook(PHo4ok854Alloc[Index] + $77, GetNodeFunc, 0);
    WPM4Byte(PHo4ok854Alloc[Index] + $87, P4a5ram);
    WPM4Byte(PHo4ok854Alloc[Index] + $8D, No15Num);
    CallHook(PHo4ok854Alloc[Index] + $92, GetNodeTransformFunc, 0);
    WPM4Byte(PHo4ok854Alloc[Index] + $A1, P4a5ram);
    WPM4Byte(PHo4ok854Alloc[Index] + $A7, Idn3dfex);
    WPM4Byte(PHo4ok854Alloc[Index] + $B0, N9o5d12es[Index]);
    WPM4Byte(PHo4ok854Alloc[Index] + $C6, MyPos);
    WPM4Byte(PHo4ok854Alloc[Index] + $CE, P4a5ram + $C);
    WPM4Byte(PHo4ok854Alloc[Index] + $D7, P4a5ram + $10);
    WPM4Byte(PHo4ok854Alloc[Index] + $E0, P4a5ram + $14);
    WPM4Byte(PHo4ok854Alloc[Index] + $E7, Bu3f4f5er);
    WPM4Byte(PHo4ok854Alloc[Index] + $EC, P4a5ram);
    CallHook(PHo4ok854Alloc[Index] + $F0, WallDistinction, 0);
    WPM4Byte(PHo4ok854Alloc[Index] + $FA, Idn3dfex);
    WPM4Byte(PHo4ok854Alloc[Index] + $103, V0i0s3idStatus[Index]);
    JmpHook(PHo4ok854Alloc[Index] + $111, PldOr3di435gil, 0);
    WPM4Byte(PHo4ok854Alloc[Index] + $118, Idn3dfex);
    WPM4Byte(PHo4ok854Alloc[Index] + $121, N9o5d12es[Index]);
    WPM4Byte(PHo4ok854Alloc[Index] + $13B, Idn3dfex);
    WPM4Byte(PHo4ok854Alloc[Index] + $144, V0i0s3idStatus[Index]);
    WPM4Byte(PHo4ok854Alloc[Index] + $152, Idn3dfex);
{$I .\Include\Virtualizer_End.inc}
  end;

  TargetPosition := 'Bip01 Head';
{$I .\Include\Virtualizer_Start.inc}
  ReadProcessMemory(hProcess, Pointer(POr8i16nalPtr[0]), @Rd518uf,
    Sizeof(Rd518uf), Pnativeuint(nil)^);
{$I .\Include\Virtualizer_End.inc}
  for Index := 0 to 31 do
  begin
  {$I .\Include\Virtualizer_Start.inc}
    P5P4t8r0[Index] := VAE($1);
    WriteProcessMemory(hProcess, Pointer(P5P4t8r0[Index]), @Rd518uf,
      Sizeof(Rd518uf), Pnativeuint(nil)^);
    WPM4Byte(P5P4t8r0[Index] + $2C, PHo4ok854Alloc[Index]);
    {$I .\Include\Virtualizer_End.inc}
  end;
end;

Function IsExistsInList(Arr: Array of DWORD; Data: DWORD): Boolean;
var
  Index: Integer;
begin
  Result := False;
  if Data = 0 then
    exit;
  for Index := 0 to 31 do
  begin
    if Arr[Index] = Data then
    begin
      Result := True;
      break;
    end;
  end;
end;

Procedure P2la4ye8rk1;
var
  Index: Integer;
  Re5a9d1Ptr: DWORD;
  B1a5s6e: Array [0 .. 31] of DWORD;
  h0O31bd5t: Array [0 .. 31] of DWORD;
begin
  for Index := 0 to 31 do
  begin
    B1a5s6e[Index] := 0;
    h0O31bd5t[Index] := 0;

    B1a5s6e[Index] := RPM4Byte(RPM4Byte(cshell.Addr + PlayerAd) + (Index * $4));

    if PlayerPointerDecrypt(RPM4Byte(B1a5s6e[Index] + $2B0)) = 0 then
      continue;

    if IsExistsInList(h0O31bd5t,
      PlayerPointerDecrypt(RPM4Byte(B1a5s6e[Index] + $2B0))) then
      continue;

    h0O31bd5t[Index] := PlayerPointerDecrypt(RPM4Byte(B1a5s6e[Index] + $2B0));

    Re5a9d1Ptr := RPM4Byte(h0O31bd5t[Index] + $ACC);

    Re5a9d1Ptr := RPM4Byte(h0O31bd5t[Index] + $ACC);
    if RPM4Byte(Re5a9d1Ptr) <> P5P4t8r0[Index] then
    begin
      if (RPM4Byte(RPM4Byte(Re5a9d1Ptr)) = POr8i16nalPtr[1]) then
        WPM4Byte(Re5a9d1Ptr, P5P4t8r0[Index]);
    end;
  end;
end;

Procedure HookPlayer;
Var
  I: Integer;
  PlayerBase: Array [0 .. 31] of DWORD;
Begin
  for I := 0 to 31 do
  begin
    PlayerBase[I] := PlayerPointerDecrypt
      (RPM4Byte(RPM4Byte(RPM4Byte(cshell.Addr + PlayerAd) + I * $4) + $2B0));
    if (RPM4Byte(RPM4Byte(PlayerBase[I] + $ACC)) = ScouterPointer[1]) then
    begin
      WPM4Byte(RPM4Byte(PlayerBase[I] + $ACC), ScouterDump);
      continue;
    end;
  end;
End;

Function GetPla8ye1rMa9trix(hO8b51j: DWORD; Bo8neNa5m1e: String): DWORD;
var
  Index: Integer;
  O1f5f6: Integer;
  P1B5a6s0e, h1e0c5t: DWORD;
begin
  Result := 0;
  If Bo8neNa5m1e = 'Bip01 Head' then
    O1f5f6 := 0;
  If Bo8neNa5m1e = 'Bip01 L Clavicle' then
    O1f5f6 := 1;
  If Bo8neNa5m1e = 'Bip01 L UpperArm' then
    O1f5f6 := 2;
  If Bo8neNa5m1e = 'Bip01 L Forearm' then
    O1f5f6 := 3;
  If Bo8neNa5m1e = 'Bip01 L Hand' then
    O1f5f6 := 4;
  If Bo8neNa5m1e = 'Bip01 R Clavicle' then
    O1f5f6 := 5;
  If Bo8neNa5m1e = 'Bip01 R UpperArm' then
    O1f5f6 := 6;
  If Bo8neNa5m1e = 'Bip01 R Forearm' then
    O1f5f6 := 7;
  If Bo8neNa5m1e = 'Bip01 R Hand' then
    O1f5f6 := 8;
  If Bo8neNa5m1e = 'Bip01 Neck' then
    O1f5f6 := 9;
  If Bo8neNa5m1e = 'Bip01 Spine2' then
    O1f5f6 := 10;
  If Bo8neNa5m1e = 'Bip01 Spine1' then
    O1f5f6 := 11;
  If Bo8neNa5m1e = 'Bip01 Spine' then
    O1f5f6 := 12;
  If Bo8neNa5m1e = 'Bip01 Pelvis' then
    O1f5f6 := 13;
  If Bo8neNa5m1e = 'Bip01 R Thigh' then
    O1f5f6 := 14;
  If Bo8neNa5m1e = 'Bip01 R Calf' then
    O1f5f6 := 15;
  If Bo8neNa5m1e = 'Bip01 R Foot' then
    O1f5f6 := 16;
  If Bo8neNa5m1e = 'Bip01 R Toe0' then
    O1f5f6 := 17;
  If Bo8neNa5m1e = 'Bip01 L Thigh' then
    O1f5f6 := 18;
  If Bo8neNa5m1e = 'Bip01 L Calf' then
    O1f5f6 := 19;
  If Bo8neNa5m1e = 'Bip01 L Foot' then
    O1f5f6 := 20;
  If Bo8neNa5m1e = 'Bip01 L Toe0' then
    O1f5f6 := 21;

  for Index := 0 to 31 do
  begin
    P1B5a6s0e := RPM4Byte(RPM4Byte(cshell.Addr + PlayerAd) + (Index * $4));
    h1e0c5t := PlayerPointerDecrypt(RPM4Byte(P1B5a6s0e + $2B0));

    if (h1e0c5t = hO8b51j) and
      (RPM4Byte(RPM4Byte(h1e0c5t + $ACC)) = P5P4t8r0[Index]) then
    begin
      Result := N9o5d12es[Index] + $40 * O1f5f6;
      break;
    end;
  end;
end;

Function GetPla0yerM0atr2ix2(h8O8b0j: DWORD; O1f58f: Integer): DWORD;
var
  Index: Integer;
  PlayerBase, hObject: DWORD;
begin
  Result := 0;

  for Index := 0 to 31 do
  begin
    PlayerBase := RPM4Byte(RPM4Byte(cshell.Addr + PlayerAd) + (Index * $4));
    hObject := PlayerPointerDecrypt(RPM4Byte(PlayerBase + $2B0));

    if (hObject = h8O8b0j) and
      (RPM4Byte(RPM4Byte(hObject + $ACC)) = P5P4t8r0[Index]) then
    begin
      Result := N9o5d12es[Index] + $40 * O1f58f;
      break;
    end;
  end;
end;

Procedure XYHook8Inl1i1ne2Asm();
Label
  Poi85nt, XY1P1o81int, Po51in1t;
Begin
  Asm
    Poi85nt:
    cmp [esp+$18],$FFFFFFFF
    je XY1P1o81int
    mov [$FFFFFFFF],eax
    jmp Po51in1t

    XY1P1o81int:
    mov [$FFFFFFFF],eax

    Po51in1t:
    movss xmm0,[eax]
    addss xmm0,dword ptr [ebp+$08]
  End;
End;

Function XYHo8o1kS6et: Boolean;
Const
  Ori8gi12na: Array [0 .. 8] Of Byte = ($F3, $0F, $10, $00, $F3, $0F, $58,
    $45, $08);
Var
  Index: Integer;
  Hoo01kA11ll88oc: Array [0 .. 2] Of DWORD;
Begin
  Try
  {$I .\Include\Virtualizer_Start.inc}
    for Index := 0 to 2 do
    Begin
      Hoo01kA11ll88oc[Index] :=
        DWORD(VirtualAllocEx(hProcess, Nil, $32, MEM_COMMIT,
        PAGE_EXECUTE_READWRITE));
    End;

    WriteProcessMemory(hProcess, ptr(Hoo01kA11ll88oc[0]), @XYHook8Inl1i1ne2Asm,
      $25, Pnativeuint(Nil)^);
    WPM4Byte(Hoo01kA11ll88oc[0] + $04, cshell.Addr + AimYStack);
    WPM4Byte(Hoo01kA11ll88oc[0] + $0C, Hoo01kA11ll88oc[1]);
    WPM4Byte(Hoo01kA11ll88oc[0] + $14, Hoo01kA11ll88oc[2]);
    JmpHook(Hoo01kA11ll88oc[0] + $21, cshell.Addr + AimHook + $9, 0);
    JmpHook(cshell.Addr + AimHook, Hoo01kA11ll88oc[0], 4);

    while True do
    Begin
      A3dX := RPM4Byte(Hoo01kA11ll88oc[1]);
      Ai34Y := RPM4Byte(Hoo01kA11ll88oc[2]);
      if (A3dX <> 0) and (Ai34Y <> 0) and (A3dX <> Ai34Y) then
      Begin
        WriteProcessMemory(hProcess, ptr(cshell.Addr + AimHook), @Ori8gi12na,
          Sizeof(Ori8gi12na), Pnativeuint(Nil)^);
        for Index := 0 to 2 do
        Begin
          VirtualFreeEx(hProcess, Pointer(Hoo01kA11ll88oc[Index]), 0,
            MEM_RELEASE);
        End;
        Result := True;
        break;
      End;
    End;
  Except
    Result := False;
  End;
  {$I .\Include\Virtualizer_End.inc}
End;

Function SetRange(Data: Single): Single;
Begin
  while (Data >= 3.141592653589793116) do
    Data := Data - 6.283185307179586477;
  while (Data < -3.1415926535897932385) do
    Data := Data + 6.283185307179586477;
  Result := Data;
End;

Procedure Aut882o1;
Var
  Index: Integer;
  Pla0t1r8ix: DWORD;
  E1yX, E5m1yY, E0ne01yZ, M0y1X, M1y8Y, M8y0Z, T1e0m2p: Single;
  N0o1wX, T8o8X, T1e8m5pX, N1o2w8Y, T0o0Y, T1e8m0pY: Single;
Begin
  for Index := 0 to 31 do
  begin

    if (RPM1Byte(cshell.Addr + DeathCheck) = 2) then
      continue;

    if (MainForm.TeamC.Checked = False) then
    Begin
      if ((RPM4Byte(cshell.Addr + Team) = 0) and
        (RPM4Byte(cshell.Addr + AimCheck) = 257)) or
        ((RPM4Byte(cshell.Addr + Team) = 1) and
        (RPM4Byte(cshell.Addr + AimCheck) = 1)) then
      else
        continue;
    End
    else
    Begin
      if (RPM4Byte(cshell.Addr + AimCheck) <> 65281) or
        (RPM4Byte(cshell.Addr + AimCheck) = 1) then
      else
        continue;
    End;

    if (MainForm.LButtonC.Checked = True) then
    Begin
      if (GetAsyncKeyState(VK_LBUTTON) <> 0) then
      else
        continue;
    End;

    if (RPM4Byte(cshell.Addr + AimCheck - $20) = 0) then
      continue;

    Pla0t1r8ix := GetPla8ye1rMa9trix(RPM4Byte(cshell.Addr + AimCheck - $20),
      TargetPosition);

    E1yX := RPMFloat(Pla0t1r8ix);
    E5m1yY := RPMFloat(Pla0t1r8ix + $4) + 3.5;
    E0ne01yZ := RPMFloat(Pla0t1r8ix + $8);

    M0y1X := RPMFloat(MyPos);
    M1y8Y := RPMFloat(MyPos + $4);
    M8y0Z := RPMFloat(MyPos + $8);

    if (A3dX <> 0) then
    begin
      N0o1wX := SetRange(RPMFloat(A3dX));
      T8o8X := ArcTan2(E1yX - M0y1X, E0ne01yZ - M8y0Z);

      if (T8o8X <= N0o1wX) then
        T1e8m5pX := N0o1wX - SetRange(N0o1wX - T8o8X) /
          MainForm.TrackBar1.Position
      else
        T1e8m5pX := SetRange(T8o8X - N0o1wX) /
          MainForm.TrackBar1.Position + N0o1wX;
      T1e8m5pX := SetRange(T1e8m5pX);

      WPMFloat(A3dX, T1e8m5pX);

      if (Ai34Y <> 0) and (MainForm.ComboBox1.ItemIndex <> 0) then
      Begin
        N1o2w8Y := SetRange(RPMFloat(Ai34Y));
        T0o0Y := ArcTan2(M1y8Y - E5m1yY,
          Sqrt(Sqr(E1yX - M0y1X) + Sqr(E0ne01yZ - M8y0Z)));

        if (T0o0Y <= N1o2w8Y) then
          T1e8m0pY := N1o2w8Y - SetRange(N1o2w8Y - T0o0Y) /
            MainForm.TrackBar2.Position
        else
          T1e8m0pY := SetRange(T0o0Y - N1o2w8Y) / MainForm.TrackBar2.Position
            + N1o2w8Y;
        T1e8m0pY := SetRange(T1e8m0pY);
        WPMFloat(Ai34Y, T1e8m0pY);
      End;
    End;
  end;
End;

End.

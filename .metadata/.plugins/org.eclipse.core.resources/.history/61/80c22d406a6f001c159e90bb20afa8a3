unit Gui14d4edUnit;

interface

uses
  Winapi.Windows, System.SysUtils, AddreUnit, Me2m4o1ryUnit,
  AimFixHookUnit, Auto1Bot3Unit,
  Math, s2e0x3U1n9i8t, Winapi.D3DX9, Winapi.Direct3D9, Winapi.DXTypes;

Procedure Gu800id1;

Function Gui88e11: Boolean;
Procedure Mi8s0s0_T;
Function PlayerPointerDecrypt(ECX: DWORD): DWORD;

var
  Gu8id1eA0ddr: DWORD;
  Gui80de1dAl0loc: Array [0 .. 1] of DWORD;
  Gu0idTog0gle: Array [0 .. 1] of DWORD;
  Gui0d1Pa0ram: Array [0 .. 3] of DWORD;
  Miss_data: integer;
  MissC: Boolean;
  ScouterAlloc, ScouterDump: DWORD;
  ScouterPointer: Array [0 .. 1] Of DWORD;
  ScouterBuffer: Array [0 .. $30] Of Byte;
    N0deV2ct0r: Array [0 .. $127] of Byte;
    TargetPosition1122: String;

implementation

uses
  Main1F0mer;

Function GetFov(PlayerPos: D3DXVECTOR3; Value: Single): BOOL;
Var
  _0Re5ct: TRect;
  X, Y, En1Fr80omX0hair: Single;
  _PlayerPos: D3DXVECTOR3;
  Width, Height, CenterX, CenterY: integer;
Begin
  Try
    Result := False;

    GetWindowRect(FindWindow(nil, 'SuddenAttack'), _0Re5ct);
    Width := _0Re5ct.Right - _0Re5ct.Left;
    Height := _0Re5ct.Bottom - _0Re5ct.Top;
    CenterX := Width div 2;
    CenterY := Height div 2;

    if (SexView(PlayerPos, _PlayerPos) = True) then
    Begin
      X := _PlayerPos.X - CenterX;
      Y := _PlayerPos.Y - CenterY;

      En1Fr80omX0hair := Sqrt((X * X) + (Y * Y));

      if (En1Fr80omX0hair >= 0.0) and (En1Fr80omX0hair <= Value) then
        Result := True;
    End;
  Except
    Result := False;
  End;
End;

Function PlayerPointerDecrypt(ECX: DWORD): DWORD;
var
  EAX: DWORD;
  DecryptFunc: Int64;
begin
  try
    Result := 0;

    EAX := RPM4Byte(ECX);
    EAX := RPM4Byte(EAX + $8);

    if EAX < cshell.Addr then
      exit;

    if RPM1Byte(EAX) = $83 then
      EAX := EAX + $9;

    DecryptFunc := RPM8Byte(EAX);

    if DecryptFunc = $222222223520418B then
      Result := RPM4Byte(ECX + $20) xor $22222222;
    if DecryptFunc = $555555553504418B then
      Result := RPM4Byte(ECX + $4) xor $55555555;
    if (PDWORD(@DecryptFunc)^ = $3520418B) and
      (PDWORD(Pointer(DWORD(@DecryptFunc) + 4))^ = $88888888) then
      Result := RPM4Byte(ECX + $20) xor $88888888;
    if DecryptFunc = $0481448B1C41B70F then
      Result := RPM4Byte(ECX + (RPM4Byte(ECX + $1C) and $FFFF) * $4 + $4)
        xor $34563456;
    if DecryptFunc = $0C81448B0841B70F then
      Result := RPM4Byte(ECX + (RPM4Byte(ECX + $8) and $FFFF) * $4 + $C)
        xor $65436543;
    if DecryptFunc = $002508413320418B then
      Result := ((RPM4Byte(ECX + $20) xor RPM4Byte(ECX + $8)) and $FFFF00)
        xor RPM4Byte(ECX + $8);
    if DecryptFunc = $002504413308418B then
      Result := ((RPM4Byte(ECX + $8) xor RPM4Byte(ECX + $4)) and $FFFF00)
        xor RPM4Byte(ECX + $4);
    if DecryptFunc = $662510413320418B then
      Result := ((RPM4Byte(ECX + $20) xor RPM4Byte(ECX + $10)) and $66666666)
        xor RPM4Byte(ECX + $20);
    if DecryptFunc = $662504413314418B then
      Result := ((RPM4Byte(ECX + $14) xor RPM4Byte(ECX + $4)) and $66666666)
        xor RPM4Byte(ECX + $14);
    if DecryptFunc = $41331841331C418B then
      Result := (RPM4Byte(ECX + $1C) xor RPM4Byte(ECX + $18))
        xor RPM4Byte(ECX + $4);
    if DecryptFunc = $41331C413320418B then
      Result := (RPM4Byte(ECX + $20) xor RPM4Byte(ECX + $1C))
        xor RPM4Byte(ECX + $4);

    if (Result = $22222222) or (Result = $55555555) or (Result = $88888888) or
      (Result = $34563456) or (Result = $65436543) then
      Result := 0;
  except
    Result := 0;
  end;
end;

Function Gui88e11: Boolean;
const
  Ma1gi8As0m: Array [0 .. 110] of Byte = ($83, $3D, $00, $00, $8B, $23, $00,
    $0F, $84, $F3, $FF, $E8, $F6, $83, $3D, $00, $00, $8A, $23, $00, $0F, $84,
    $E6, $FF, $E8, $F6, $A1, $00, $00, $8C, $23, $89, $85, $54, $FF, $FF, $FF,
    $A1, $04, $00, $8C, $23, $89, $85, $58, $FF, $FF, $FF, $A1, $08, $00, $8C,
    $23, $89, $85, $5C, $FF, $FF, $FF, $8D, $85, $54, $FF, $FF, $FF, $50, $A1,
    $00, $00, $8D, $23, $89, $85, $F4, $FE, $FF, $FF, $A1, $04, $00, $8D, $23,
    $89, $85, $F8, $FE, $FF, $FF, $A1, $08, $00, $8D, $23, $89, $85, $FC, $FE,
    $FF, $FF, $8D, $85, $F4, $FE, $FF, $FF, $50, $E9, $9F, $FF, $E8, $F6);
  Mag0i1nalA1sm: Array [0 .. 18] of Byte = ($8D, $85, $58, $FF, $FF, $FF, $50,
    $8D, $85, $F4, $FE, $FF, $FF, $50, $E9, $9F, $01, $F6, $FF);
  Bul0l18e: Array [0 .. 11] of Byte = ($4C, $74, $CC, $3D, $98, $B8, $7E, $BF,
    $00, $44, $2E, $3A);
var
  Index: integer;
begin
{$I .\Include\Virtualizer_Start.inc}
  for Index := 0 to 1 do
    Gui80de1dAl0loc[Index] := DWORD(VirtualAllocEx(hProcess, nil, $1FC0,
      MEM_COMMIT, PAGE_EXECUTE_READWRITE));
  for Index := 0 to 1 do
    Gu0idTog0gle[Index] := DWORD(VirtualAllocEx(hProcess, nil, $1F00,
      MEM_COMMIT, PAGE_EXECUTE_READWRITE));
  for Index := 0 to 1 do
    Gui0d1Pa0ram[Index] := DWORD(VirtualAllocEx(hProcess, nil, $2F00,
      MEM_COMMIT, PAGE_EXECUTE_READWRITE));

  WriteProcessMemory(hProcess, Pointer(Gui80de1dAl0loc[0]), @Ma1gi8As0m,
    SizeOf(Ma1gi8As0m), PNativeUInt(nil)^);
  WPM4Byte(Gui80de1dAl0loc[0] + 2, Gu0idTog0gle[0]);
  WPM4Byte(Gui80de1dAl0loc[0] + 7 + 2, Gui80de1dAl0loc[1] -
    (Gui80de1dAl0loc[0] + 7) - 6);
  WPM4Byte(Gui80de1dAl0loc[0] + $14 + 2, Gui80de1dAl0loc[1] -
    (Gui80de1dAl0loc[0] + $14) - 6);
  WPM4Byte(Gui80de1dAl0loc[0] + $F, Gu0idTog0gle[1]);
  for Index := 0 to 2 do
    WPM4Byte(Gui80de1dAl0loc[0] + $1B + $B * Index, Gui0d1Pa0ram[0] +
      Index * 4);
  for Index := 0 to 2 do
    WPM4Byte(Gui80de1dAl0loc[0] + $43 + $B * Index, Gui0d1Pa0ram[1] +
      Index * 4);
  JmpHook(Gui80de1dAl0loc[0] + $6A, Gui80de1dAl0loc[1] + $E, 0);

  WriteProcessMemory(hProcess, Pointer(Gui80de1dAl0loc[1]), @Mag0i1nalA1sm,
    SizeOf(Mag0i1nalA1sm), PNativeUInt(nil)^);
  JmpHook(Gui80de1dAl0loc[1] + $E, cshell.Addr + AimFixAddr + $1C4 + $23, 0);

  JmpHook(AimFixCopy+ $1D9, Gui80de1dAl0loc[0], 0);

  WriteProcessMemory(hProcess, Pointer(Gui0d1Pa0ram[1]), @Bul0l18e,
    SizeOf(Bul0l18e), PNativeUInt(nil)^);
    {$I .\Include\Virtualizer_End.inc}
end;

Function PosCalc(PosBase: DWORD): D3DXVECTOR3;
Begin
  Result.X := RPMFloat(PosBase);
  Result.Y := RPMFloat(PosBase + 4) + 3.5;;
  Result.z := RPMFloat(PosBase + 8);
End;

Function GetNearestBone(hO81b0t: DWORD): D3DXVECTOR3;
Var
  tSi0z1e: TRect;
  Bo8n1eM: DWORD;
  Min4Bo18ne1: Single;
  Bon1e2D8Pos: D3DXVECTOR3;
  Index, CenterX, CenterY: integer;
  B1P8o0s: Array [0 .. 21] Of D3DXVECTOR3;
  En1Fr80omX0hair: Array [0 .. 21] Of Single;
  Width, Height: integer;
Begin
  Try
    GetClientRect(FindWindow(nil, 'SuddenAttack'), tSi0z1e);
    Width := tSi0z1e.Right - tSi0z1e.Left;
    Height := tSi0z1e.Bottom - tSi0z1e.Top;

    Result.X := 0;

    CenterX := Width div 2;
    CenterY := Height div 2;

    for Index := 0 to 21 do
    Begin
      Bo8n1eM := GetPla0yerM0atr2ix2(hO81b0t, Index);
      B1P8o0s[Index] := PosCalc(Bo8n1eM);

      if (SexView(B1P8o0s[Index], Bon1e2D8Pos) = True) then
        En1Fr80omX0hair[Index] :=
          Sqrt(Sqr(Bon1e2D8Pos.X - CenterX) + Sqr(Bon1e2D8Pos.Y - CenterY));
    End;

    for Index := 0 to 21 do
    Begin
      if (En1Fr80omX0hair[Index] = MinValue(En1Fr80omX0hair)) then
      Begin
        Result := B1P8o0s[Index];
        Break;
      End;
    End;
  Except
    Result.X := 0;
  End;
End;

Procedure Gu800id1;
var
  Index, Pl1et821Index: integer;
  P0lM1atrix, L1i1v0e, T2e10m1, T01a01m2, C1he0c0k, In1vi8nc0ibi0lity: DWORD;
  F1X, F0Y, F78Z, H1Ar2ea8X, H2it1Ar9eaY, H12Ar0e8aZ: Single;
  E1P8o0s, L1P0o80s, T1P0o8s: D3DXVECTOR3;
  Pl18Ba0s0e1: Array [0 .. 31] of DWORD;
  Pl1Ba80s0e2: Array [0 .. 31] of DWORD;
begin
  Pl1et821Index := 0;
  for Index := 0 to 31 do
  begin
    if (InGame = 0) then
    begin
      WPM4Byte(Gu0idTog0gle[1], 0);
      continue;
    end;

    if (DeathCheck = 2) then
    begin
      WPM4Byte(Gu0idTog0gle[1], 0);
      continue;
    end;

    Pl18Ba0s0e1[Index] := RPM4Byte(RPM4Byte(cshell.Addr + PlayerAd) +
      (Index * $4));
    Pl1Ba80s0e2[Index] := PlayerPointerDecrypt
      (RPM4Byte(Pl18Ba0s0e1[Index] + $2B0));
    if MissC = True then
      continue;

    T2e10m1 := RPM1Byte(cshell.Addr + Team);
    T01a01m2 := RPM1Byte(Pl18Ba0s0e1[Index] + $5C);
    L1i1v0e := RPM1Byte(Pl18Ba0s0e1[Index] + $2B4);
    C1he0c0k := RPM1Byte(Pl18Ba0s0e1[Index] + $74);
    In1vi8nc0ibi0lity := RPM1Byte(Pl1Ba80s0e2[Index] + $E6);

    if (L1i1v0e <> 1) then
    begin
      continue;
    end;

    if (RPM1Byte(V0i0s3idStatus[Index]) <> 1) then
    Begin
      continue;
    end;

    if (In1vi8nc0ibi0lity <> $FF) then
    begin
      continue;
    end;

    if (MainForm.TeamC.Checked = False) then
    begin
      if (T2e10m1 = T01a01m2) then
        continue;
    end
    else
    begin
      if (Pl1Ba80s0e2[Index] = RPM4Byte(RPM4Byte(RPM4Byte(cshell.Addr + English
        + $FE4) + $4A8) + $14)) then
        continue;
    end;

    E1P8o0s.X := RPMFloat(Pl1Ba80s0e2[Index] + $12C);
    E1P8o0s.Y := RPMFloat(Pl1Ba80s0e2[Index] + $130);
    E1P8o0s.z := RPMFloat(Pl1Ba80s0e2[Index] + $134);

    T1P0o8s := GetNearestBone(Pl1Ba80s0e2[Index]);


    L1P0o80s.X := RPMFloat(MyPos);
    L1P0o80s.Y := RPMFloat(MyPos + $4) + 3.5;
    L1P0o80s.z := RPMFloat(MyPos + $8);

    if (MainForm.F1o2v8C.Checked = True) then
    begin
      if (GetFov(E1P8o0s, MainForm.FovV8alu15lBar.Position) = False) then
        continue;
    end;

    H1Ar2ea8X := Sin(SetRange(ArcTan2(T1P0o8s.X - L1P0o80s.X,
      T1P0o8s.z - L1P0o80s.z)));
    H2it1Ar9eaY := Tan(-ArcTan2(L1P0o80s.Y - T1P0o8s.Y,
      Sqrt(Sqr(T1P0o8s.X - L1P0o80s.X) + Sqr(T1P0o8s.z - L1P0o80s.z))));
    H12Ar0e8aZ := Cos(SetRange(ArcTan2(T1P0o8s.X - L1P0o80s.X,
      T1P0o8s.z - L1P0o80s.z)));

    F1X := Sin(SetRange(ArcTan2(T1P0o8s.X - E1P8o0s.X, T1P0o8s.z - E1P8o0s.z)));
    F0Y := Tan(-ArcTan2(E1P8o0s.Y - T1P0o8s.Y,
      Sqrt(Sqr(T1P0o8s.X - E1P8o0s.X) + Sqr(T1P0o8s.z - E1P8o0s.z))));
    F78Z := Cos(SetRange(ArcTan2(T1P0o8s.X - E1P8o0s.X,
      T1P0o8s.z - E1P8o0s.z)));

    WPMFloat(Gui0d1Pa0ram[0], L1P0o80s.X);
    WPMFloat(Gui0d1Pa0ram[0] + 4, L1P0o80s.Y);
    WPMFloat(Gui0d1Pa0ram[0] + 8, L1P0o80s.z);

    WPMFloat(Gui0d1Pa0ram[1], H1Ar2ea8X);
    WPMFloat(Gui0d1Pa0ram[1] + 4, H2it1Ar9eaY);
    WPMFloat(Gui0d1Pa0ram[1] + 8, H12Ar0e8aZ);

    WPMFloat(Gui0d1Pa0ram[2], E1P8o0s.X);
    WPMFloat(Gui0d1Pa0ram[2] + 4, E1P8o0s.Y);
    WPMFloat(Gui0d1Pa0ram[2] + 8, E1P8o0s.z);

    WPMFloat(Gui0d1Pa0ram[3], F1X);
    WPMFloat(Gui0d1Pa0ram[3] + 4, F0Y);
    WPMFloat(Gui0d1Pa0ram[3] + 8, F78Z);

    WPM4Byte(Gu0idTog0gle[0], 1);
    WPM4Byte(Gu0idTog0gle[1], 1);

    Pl1et821Index := Pl1et821Index + 1;
  end;
  if (Pl1et821Index = 0) then
    WPM4Byte(Gu0idTog0gle[1], 0);
end;

Procedure Mi8s0s0_T;
begin
  Randomize;
  Miss_data := RandomRange(1, 100);
  if Miss_data <= MainForm.TrackBar4.Position then
  begin
    MissC := True;
  end
  ELSE
  begin
    MissC := False;
  end;
end;

end.
